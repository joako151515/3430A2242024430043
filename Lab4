#include <iostream>
#include <fstream>
#include <cstdlib>  // system()
using namespace std;

struct Node {
    int info;
    Node* left;
    Node* right;
};

// Crear un nuevo nodo
Node* createNode(int value) {
    Node* n = new Node;
    n->info = value;
    n->left = NULL;
    n->right = NULL;
    return n;
}

// Buscar si un valor existe en el árbol
bool exists(Node* root, int value) {
    Node* aux = root;
    while (aux != NULL) {
        if (value == aux->info) return true;
        else if (value < aux->info) aux = aux->left;
        else aux = aux->right;
    }
    return false;
}

// Insertar un valor en el ABB (sin duplicados)
Node* insert(Node* root, int value) {
    if (root == NULL) {
        return createNode(value);
    }
    if (value < root->info) {
        root->left = insert(root->left, value);
    } else if (value > root->info) {
        root->right = insert(root->right, value);
    }
    return root;
}

// Encontrar el nodo con el valor mínimo (para eliminación)
Node* findMin(Node* node) {
    Node* current = node;
    while (current != NULL && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Eliminar un valor del ABB
Node* remove(Node* root, int value) {
    if (root == NULL) return root;

    if (value < root->info) {
        root->left = remove(root->left, value);
    } else if (value > root->info) {
        root->right = remove(root->right, value);
    } else {
        // Nodo encontrado
        if (root->left == NULL) {
            Node* temp = root->right;
            delete root;
            return temp;
        } else if (root->right == NULL) {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        // Nodo con dos hijos
        Node* temp = findMin(root->right);
        root->info = temp->info;
        root->right = remove(root->right, temp->info);
    }
    return root;
}

// Modificar un elemento: eliminar viejo e insertar nuevo
Node* modify(Node* root, int oldValue, int newValue) {
    if (!exists(root, oldValue)) {
        cout << "El valor " << oldValue << " no existe.\n";
        return root;
    }
    if (exists(root, newValue)) {
        cout << "El nuevo valor " << newValue << " ya existe.\n";
        return root;
    }
    root = remove(root, oldValue);
    root = insert(root, newValue);
    cout << "Valor " << oldValue << " modificado por " << newValue << ".\n";
    return root;
}

// Recorrido en preorden
void preorden(Node* root) {
    if (root != NULL) {
        cout << root->info << " ";
        preorden(root->left);
        preorden(root->right);
    }
}

// Recorrido en inorden
void inorden(Node* root) {
    if (root != NULL) {
        inorden(root->left);
        cout << root->info << " ";
        inorden(root->right);
    }
}

// Recorrido en posorden
void posorden(Node* root) {
    if (root != NULL) {
        posorden(root->left);
        posorden(root->right);
        cout << root->info << " ";
    }
}

// Escribir estructura del árbol en formato DOT (Graphviz)
void escribirDot(Node* node, ofstream& out) {
    if (node != NULL) {
        if (node->left != NULL) {
            out << node->info << "->" << node->left->info << ";" << endl;
        } else {
            out << "\"" << node->info << "i\" [shape=point];" << endl;
            out << node->info << "->\"" << node->info << "i\";" << endl;
        }

        if (node->right != NULL) {
            out << node->info << "->" << node->right->info << ";" << endl;
        } else {
            out << "\"" << node->info << "d\" [shape=point];" << endl;
            out << node->info << "->\"" << node->info << "d\";" << endl;
        }

        escribirDot(node->left, out);
        escribirDot(node->right, out);
    }
}

// Generar archivo DOT y la imagen PNG con Graphviz
void graficar(Node* root) {
    ofstream out("grafo.txt");
    if (!out.is_open()) {
        cout << "Error al crear el archivo grafo.txt\n";
        return;
    }

    out << "digraph G {\n";
    out << "node [style=filled fillcolor=yellow];\n";
    escribirDot(root, out);
    out << "}\n";
    out.close();

    system("dot -Tpng -ografo.png grafo.txt");
    system("eog grafo.png");
    cout << "Grafo generado como grafo.png\n";
}

// Liberar memoria del árbol
void liberar(Node* root) {
    if (root != NULL) {
        liberar(root->left);
        liberar(root->right);
        delete root;
    }
}

// MENÚ PRINCIPAL
int main() {
    Node* root = NULL;
    int opcion, valor, nuevo;

    do {
        cout << "\n===== MENU LABORATORIO 4 =====\n";
        cout << "1. Insertar numero\n";
        cout << "2. Eliminar numero\n";
        cout << "3. Modificar numero\n";
        cout << "4. Mostrar recorridos\n";
        cout << "5. Generar grafo (Graphviz)\n";
        cout << "6. Salir\n";
        cout << "Opcion: ";
        cin >> opcion;

        switch (opcion) {
            case 1:
                cout << "Ingrese valor a insertar: ";
                cin >> valor;
                if (exists(root, valor)) {
                    cout << "El valor ya existe.\n";
                } else {
                    root = insert(root, valor);
                    cout << "Insertado correctamente.\n";
                }
                break;

            case 2:
                cout << "Ingrese valor a eliminar: ";
                cin >> valor;
                if (!exists(root, valor)) {
                    cout << "El valor no existe.\n";
                } else {
                    root = remove(root, valor);
                    cout << "Eliminado correctamente.\n";
                }
                break;

            case 3:
                cout << "Valor a modificar: ";
                cin >> valor;
                cout << "Nuevo valor: ";
                cin >> nuevo;
                root = modify(root, valor, nuevo);
                break;

            case 4:
                cout << "Preorden: ";
                preorden(root);
                cout << "\nInorden: ";
                inorden(root);
                cout << "\nPosorden: ";
                posorden(root);
                cout << endl;
                break;

            case 5:
                graficar(root);
                break;

            case 6:
                cout << "Saliendo...\n";
                break;

            default:
                cout << "Opcion no valida.\n";
        }
    } while (opcion != 6);

    liberar(root);
    return 0;
}
